#+title: Chapter1 3 1
#+author: 暮玖(github@mujiu555)

* 1.3.1 Procedures as Arguments
Consider the following three procedures.
The first computes the sum of the integers from _a_ through _b_:

考虑以下三个过程.
第一个过程计算从 a 到 b 的整数之和:

#+begin_src scheme
(define (sum-integers a b)
  (if (> a b)
      0
      (+ a (sum-integers (+ a 1) b))))
#+end_src

The second computes the sum of the cubes of the integers in the
given range:

第二个过程计算给定范围内整数的立方和:

#+begin_src scheme
(define (sum-cubes a b)
  (if (> a b)
      0
      (+ (cube a)
         (sum-cubes (+ a 1) b))))
#+end_src

The third computes the sum of a sequence of terms in the series

第三个过程计算以下序列

#+begin_example
    1       1       1
  ----- + ----- + ----- + …,
   1⋅3     5⋅7     9⋅11
#+end_example

which converges to _π/8_
 (very slowly): [fn:1]

的和, 该序列非常缓慢地收敛到 pi/8:

#+begin_src scheme
(define (pi-sum a b)
  (if (> a b)
      0
      (+ (/ 1.0 (* a (+ a 2)))
         (pi-sum (+ a 4) b))))
#+end_src

These three procedures clearly share a common underlying
pattern.
They are for the most part identical, differing only in the
name of the procedure, the function of a used to compute the
term to be added, and the function that provides the next value
of a.
We could generate each of the procedures by filling in slots in
the same template:

这三个过程显然共享一个共同的基本模式.
它们大部分是相同的, 仅在过程名称, 用于计算要被添加的项的函数和提供 a 的下一个值的函数方面有所不同.
我们可以通过填充同一个模板中的 槽 来生成每个过程.

#+begin_src scheme
(define (⟨name⟩ a b)
  (if (> a b)
      0
      (+ (⟨term⟩ a)
         (⟨name⟩ (⟨next⟩ a) b))))
#+end_src

The presence of such a common pattern is strong evidence that
there is a useful abstraction waiting to be brought to the
surface.
Indeed, mathematicians long ago identified the abstraction of
/summation of a series/ and invented “sigma notation,” for
example

这种共同模式的存在强烈表明有一种有用的抽象正等待被提取出.
事实上, 数学家早就确定了序列求和的抽象, 并发明了 "Sigma 符号",
例如:

#+begin_example
 b
 ∑ f(n)=f(a)+⋯+f(b),
n=a
#+end_example

to express this concept.
The power of sigma notation is that it allows mathematicians to
deal with the concept of summation itself rather than only with
particular sums—for example, to formulate general results about
sums that are independent of the particular series being summed.

Sigma 符号的强大之处在于, 它使得数学家可以处理 "求和"
这一概念本身, 而不是特定的求和,
以允许规范化与特定被求和序列无关的通用结果.

Similarly, as program designers, we would like our language to
be powerful enough so that we can write a procedure that
expresses the concept of summation itself rather than only
procedures that compute particular sums.
We can do so readily in our procedural language by taking the
common template shown above and transforming the “slots” into
formal parameters:

类似的, 作为程序设计者, 我们期望我们的语言足够强大,
以至于我们可以写出一个表达求和本身而非仅仅处理特定仇和的过程.
我们可以通过将上述通用模板中的 "插槽" 变为参数来实现这一点:

#+begin_src scheme
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
#+end_src

Notice that *sum* takes as its arguments the lower and upper
bounds a and b together with the procedures *term* and *next*.
We can use *sum* just as we would any procedure.
For example, we can use it (along with a procedure *inc* that
increments its argument by 1) to define *sum-cubes*:

注意到, sum 接受作为参数的上下界 a 和 b, 以及过程 term 和 next.
我们可以像使用任何其他过程一样使用 sum.
如, 我们可以用它 (和一个用 1 递增它的参数值的过程 inc) 来定义
sum-cubes:

#+begin_src scheme
(define (inc n) (+ n 1))

(define (sum-cubes a b)
  (sum cube a inc b))
#+end_src

Using this, we can compute the sum of the cubes of the integers
from 1 to 10:

通过这些过程, 我们就可以计算 1 到 10 之间的立方和:

#+begin_src scheme
(sum-cubes 1 10)
3025
#+end_src

With the aid of an identity procedure to compute the term, we
can define *sum-integers* in terms of *sum*:

借助项的恒等过程, 我们可以用 sum 定义 sum-integers:

#+begin_src scheme
(define (identity x) x)

(define (sum-integers a b)
  (sum identity a inc b))
#+end_src

Then we can add up the integers from 1 to 10:

于是我们可以求 1 到 10 的整数和:

#+begin_src scheme
(sum-integers 1 10)
55
#+end_src

We can also define *pi-sum* in the same way: [fn:2]

我们也可以用同样方式定义 pi-sum: [fn:2]

#+begin_src scheme
(define (pi-sum a b)
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))
  (define (pi-next x)
    (+ x 4))
  (sum pi-term a pi-next b))
#+end_src

Using these procedures, we can compute an approximation to _π_:

使用这些过程, 我们可以计算 pi 的近似值:

#+begin_src scheme
(* 8 (pi-sum 1 1000))
3.139592655589783
#+end_src

Once we have *sum*, we can use it as a building block in
formulating further concepts.
For instance, the definite integral of a function _f_
between the limits _a_ and _b_ can be approximated numerically
using the formula

我们有了 sum, 就可以将其作为构建新概念的组建.
例如, 函数 f 关于小量 dx 在区间 [a, b] 上的定积分可以通过公式

#+begin_example
b
∫ f=[f(a+dx/2)+f(a+dx+dx/2)+f(a+2dx+dx/2)+…]dx
a
#+end_example

for small values of _dx_.
We can express this directly as a procedure:

来估算.
我们可以直接将其表示为一个过程:

#+begin_src scheme
(define (integral f a b dx)
  (define (add-dx x) (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b)
     dx))

(integral cube 0 1 0.01)
.24998750000000042

(integral cube 0 1 0.001)
.249999875000001
#+end_src

(The exact value of the integral of cube between 0 and 1 is 1/4.)

(从 0 到 1 的立方的积分的确切值是 1/4)

** Exercise 1.29:
Simpson’s Rule is a more accurate method of numerical
integration than the method illustrated above.
Using Simpson’s Rule, the integral of a function f between a
and b is approximated as

#+begin_example
h
- * (y0 + 4y1 + 2y2 + 4y3 + 2y4 + ⋯ + 2yn − 2 + 4yn − 1 + yn),
3
#+end_example

where _h = (b−a)/n_, for some even integer _n_, and
_y_k = f(a+kh)_.
(Increasing _n_ increases the accuracy of the approximation.)
Define a procedure that takes as arguments _f_, _a_, _b_, and
_n_ and returns the value of the integral, computed using
Simpson’s Rule.
Use your procedure to integrate cube between 0 and 1 (with
n=100 and n=1000), and compare the results to those of the
*integral* procedure shown above.

** Exercise 1.30:
The sum procedure above generates a linear recursion.
The procedure can be rewritten so that the sum is performed
iteratively.
Show how to do this by filling in the missing expressions in
the following definition:

#+begin_src scheme
(define (sum term a next b)
  (define (iter a result)
    (if ⟨??⟩
        ⟨??⟩
        (iter ⟨??⟩ ⟨??⟩)))
  (iter ⟨??⟩ ⟨??⟩))
#+end_src

** Exercise 1.31:

1. The sum procedure is only the simplest of a vast number of
   similar abstractions that can be captured as higher-order
   procedures.[fn:3]
   Write an analogous procedure called product that returns
   the product of the values of a function at points over a
   given range.
   Show how to define factorial in terms of product.
   Also use product to compute approximations to _π_ using
   the formula [fn:4]

#+begin_example
π    2⋅4⋅4⋅6⋅6⋅8⋅⋯
- = ---------------- .
4    3⋅3⋅5⋅5⋅7⋅7⋅⋯
#+end_example

2. If your product procedure generates a recursive process,
   write one that generates an iterative process.
   If it generates an iterative process, write one that
   generates a recursive process.

** Exercise 1.32:

1. Show that sum and product ([[Exercise 1.31:][Exercise 1.31]]) are both special
   cases of a still more general notion called *accumulate*
   that combines a collection of terms, using some general
   accumulation function:

#+begin_src scheme
(accumulate
 combiner null-value term a next b)
#+end_src

*Accumulate* takes as arguments the same term and range
specifications as *sum* and *product*, together with a
*combiner* procedure (of two arguments) that specifies how
the current term is to be combined with the accumulation of
the preceding terms and a *null-value* that specifies what
base value to use when the terms run out.
Write *accumulate* and show how sum and product can both be
defined as simple calls to accumulate.

2. If your *accumulate* procedure generates a recursive
   process, write one that generates an iterative process.
   If it generates an iterative process, write one that
   generates a recursive process.

** Exercise 1.33:
You can obtain an even more general version of *accumulate*
([[Exercise 1.32:][Exercise 1.32]]) by introducing the notion of a filter on the
terms to be combined.
That is, combine only those terms derived from values in the
range that satisfy a specified condition.
The resulting *filtered-accumulate* abstraction takes the
same arguments as accumulate, together with an additional
predicate of one argument that specifies the filter.
Write *filtered-accumulate* as a procedure.
Show how to express the following using *filtered-accumulate*:

1. the sum of the squares of the prime numbers in the
   interval a to b
   (assuming that you have a *prime?* predicate already
   written)
2. the product of all the positive integers less than n
   that are relatively prime to n
   (i.e., all positive integers i<n such that GCD(i,n)=1).

* Footnotes
[fn:1] This series, usually written in the equivalent form π4=1−13+15−17+…, is due to Leibniz. We’ll see how to use this as the basis for some fancy numerical tricks in 3.5.3.

[fn:2] Notice that we have used block structure (1.1.8) to embed the definitions of pi-next and pi-term within pi-sum, since these procedures are unlikely to be useful for any other purpose. We will see how to get rid of them altogether in 1.3.2.

[fn:3] The intent of Exercise 1.31 through Exercise 1.33 is to demonstrate the expressive power that is attained by using an appropriate abstraction to consolidate many seemingly disparate operations. However, though accumulation and filtering are elegant ideas, our hands are somewhat tied in using them at this point since we do not yet have data structures to provide suitable means of combination for these abstractions. We will return to these ideas in 2.2.3 when we show how to use sequences as interfaces for combining filters and accumulators to build even more powerful abstractions. We will see there how these methods really come into their own as a powerful and elegant approach to designing programs.

[fn:4] This formula was discovered by the seventeenth-century English mathematician John Wallis.
