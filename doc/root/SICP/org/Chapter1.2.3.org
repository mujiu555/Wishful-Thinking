#+title: Chapter 1.2.3
#+author: 暮玖(github@mujiu555)

* 1.2.3 Orders of Growth 增长顺序

The previous examples illustrate that processes can
differ considerably in the rates at which they
consume computational resources. One convenient way
to describe this difference is to use the notion of
/order of growth/ to obtain a gross measure of the
resources required by a process as the inputs
become larger.

上一个例子展示了可以用它们消耗的资源的变化率
区分的进程.
一个用于描述这种差异的方式是用 "增长顺序" 表示
去获取一个进程随输入增长的需要的资源的数量级.

Let n be a parameter that measures the size of the
problem, and let R(n) be the amount of resources
the process requires for a problem of size n . In
our previous examples we took n to be the number
for which a given function is to be computed, but
there are other possibilities. For instance, if our
goal is to compute an approximation to the square
root of a number, we might take n to be the number
of digits accuracy required. For matrix
multiplication we might take n to be the number of
rows in the matrices. In general there are a number
of properties of the problem with respect to which
it will be desirable to analyze a given process.
Similarly, R(n) might measure the number of
internal storage registers used, the number of
elementary machine operations performed, and so on.
In computers that do only a fixed number of
operations at a time, the time required will be
proportional to the number of elementary machine
operations performed.

令 n 是一个测量问题规模的参数,
并且 R(n) 是进程处理具有规模 n 的问题是需要的资源.
在我们之前的例子中我们采用 n 作为一个特定的函数
需要计算的数, 但是还有其他的可能性.
例如, 如果我们的目标是计算出一个数的平方根的估值,
我们也许需要让 n 作为需要的数的精度.
对于矩阵乘法, 我们也许令 n 作为矩阵的行数.
总的而言,
那里总是有可取用于分析给定进程的问题的属性.
相似得, R(n) 也许量定了内部用到的存储寄存器的数量,
被执行的基础机器操作的数量, 等等.
在一台固定时间内只能进行固定数量操作的计算机中,
所需要的时间与需要执行的基本机器操作
(machine instruction, 机器指令)的数量成比例.

We say that R(n) has order of growth Θ(f(n)) ,
written R(n) = Θ(f(n)) (pronounced “theta of f(n)
”), if there are positive constants k_1 and k_2
independent of n such that k_1 f(n) ≤ R(n) ≤ k_2
f(n) for any sufficiently large value of n . (In
other words, for large n , the value R(n) is
sandwiched between k_1 f(n) and k_2 f(n) .)

如果存在正常量 k_1 和 k_2 独立于 n,
使得 k_1 f(n) <= R(n) <= k_2 f(n)
对于任何足够大的 n 成立.
我们说 R(n) 有着 Θ(f(n)) 的增长顺序,
写作 R(n) = Θ(f(n)) (读作 "theta f(n)", f(n)的确界).
(另一种说法, 对于大数 n,
R(n)的值在 k_1 f(n) 和 k_2 f(n) 之间.)

For instance, with the linear recursive process for
computing factorial described in [[file:Chapter1.2.1.org][1.2.1]] the number
of steps grows proportionally to the input n .
Thus, the steps required for this process grows as
Θ(n) . We also saw that the space required grows
as Θ(n) . For the iterative factorial, the
number of steps is still Θ(n) but the space is Θ(1)
— that is, constant [fn:1]. The tree-recursive
Fibonacci computation requires Θ(φ^n) steps and
space Θ(n) , where φ is the golden ratio described
in [[file:Chapter1.2.2.org][1.2.2]].

例如, 如 [[file:Chapter1.2.1.org][1.2.1]] 节描述的用于计算阶乘的
线性递归进程, 它的步骤就随着输入 n 成比例增长.
于是, 这个进程所需的步骤以 Θ(n) 增长.
我们也可以看到空间需求(也)以 Θ(n) 增长.
对于迭代阶乘, 需要的步骤仍然是 Θ(n),
但是, 空间(需求)是 Θ(1) --- 即, 常数[fn:1].
树状递归的斐波那契计算需要 Θ(φ^n) 步, Θ(n) 的空间,
φ 是在 [[file:Chapter1.2.2.org][1.2.2]] 节描述的黄金比例.


Orders of growth provide only a crude description
of the behavior of a process. For example, a
process requiring n^2 steps and a process requiring
1000 n^2 steps and a process requiring
3 n^2 + 10 n + 17
steps all have Θ(n^2) order of growth. On the
other hand, order of growth provides a useful
indication of how we may expect the behavior of the
process to change as we change the size of the
problem. For a Θ(n) (linear) process, doubling the
size will roughly double the amount of resources
used. For an exponential process, each increment in
problem size will multiply the resource utilization
by a constant factor. In the remainder of [[file:Chapter1.2.org][1.2]] we
will examine two algorithms whose order of growth
is logarithmic, so that doubling the problem size
increases the resource requirement by a constant
amount.

增长顺序提供了一种对进程行为的简陋描述.
例如, 一个需要 n^2 步的进程,
一个需要 1000 n^2 步的进程和一个需要
3 n^2 + 10 n + 17
步的进程, 它们都有 Θ(n^2) 的增长顺序.
另一方面, 增长顺序提供了一个我们可以期待
当我们改变问题规模时进程行为的改变的有用指标.
对于一个 Θ(n) (线性)进程,
翻倍它的规模大概会翻倍需要的资源.
对于一个指数进程, 任何问题规模上的增长都会以一个常数翻倍使用的资源.
在 1.2 节的余下部分中我们将要看到两个增长顺序
是对数的算法,
所以问题规模的翻倍仅以常数规模增长需求的资源[fn:2].

**** Exercise 1.14:
    Draw the tree illustrating the process
    generated by the *count-change* procedure
    of [[file:Chapter1.2.2.org][1.2.2]] in making change for 11 cents.
    What are the orders of growth of the
    space and number of steps used by this
    process as the amount to be changed
    increases?

    画一个树描述由第 [[file:Chapter1.2.2.org][1.2.2]] 节中的 count-change 产生的进程在兑换 11 美分时(的状态).
    这个进程的 amount 在增长的时候它的空间和步骤的增长顺序是什么?

**** Exercise 1.15:
    The sine of an angle (specified in
    radians) can be computed by making use of
    the approximation sin ⁡ x ≈ x if x is
    sufficiently small, and the trigonometric
    identity

    一个角的正弦(弧度制)可以用 当 x 足够小时 sin x ~= x 来估计, 并且三角函数成立

    #+begin_example
                     x             x
    sin ⁡ x = 3 sin --- − 4 sin^3 ---
                     3             3
    #+end_example

    to reduce the size of the argument of
    sin. (For purposes of this exercise an
    angle is considered “sufficiently small”
    if its magnitude is not greater than 0.1
    radians.) These ideas are incorporated in
    the following procedures:

    来化简 sin 的参数的大小.
    (为满足这个练习的"足够小",
    一个角在它的大小小于等于 0.1 弧度时成立.)
    这个想法由如下函数注册:

    #+begin_src scheme
    (define (cube x) (* x x x))
    (define (p x) (- (* 3 x) (* 4 (cube x))))
    (define (sine angle)
       (if (not (> (abs angle) 0.1))
           angle
           (p (sine (/ angle 3.0)))))

    #+end_src

        1. How many times is the procedure *p* applied when *(sine 12.15)* is evaluated?
        2. What is the order of growth in space and number of steps (as a function of a ) used by the process generated by the sine procedure when *(sine a)* is evaluated?

        1. 当(sine 12.15)被求值时, 函数 p 被调用了多少次?

        2. 当(sine a) 被求值时, sine 函数产生的进程在空间和步骤上的增长顺序(作为 f(a))是什么?


* Footnotes
[fn:2] 对于 OI 来说, theta 也许很熟悉, 实际上复杂度是这些东西的前置值时, 对算法的描述有很多种, 包括时间复杂度(基本语句与问题规模 N 之间的数学表达式), 空间复杂度, 它们并不需要也无法被精确计算出结果. 因此需要用渐进符号表示复杂度.
渐进符号:
渐进符号是函数阶的规范描述, 是用于描述函数渐进行为的符号, 可以认为是忽略了函数中增长较慢的部分和系数(常数)部分, 得到的用来表示函数增长趋势的部分
简单而言, 含等于大写, 否则小写, 严格等于 theta(确界), 小于 Omicron(上界), 大于 Omega(下界)
1. 大 O 渐进表示法, 它用另一个函数描述一个函数数量级的渐进上界. 当且仅当 Exist c, n_0 => All n >= n_0, 0 <= f(n) <= c * g(n) 存在 f(n) = O(g(n)).
2. 大 Theta, 其描述在正文中出现过了
3. 大 Omega, 表示函数的渐进下界. f(n) = Omega(g(n)) <=> Exist c, n_0 => Any n >= n_0, 0 <= c * g(n) <= f(n).
可用大 O 表示法表示算法的最坏时间复杂度(注:大 O 表示法并非最坏时间复杂度, 仅代表函数变化的上界)
参见[[https://oi-wiki.org/basic/complexity/][OI Wiki]]
参见[[https://blog.csdn.net/weixin_50502862/article/details/126718926][算法设计与分析-CSDN Blog]]

[fn:1] These statements mask a great deal of oversimplification. For instance, if we count process steps as “machine operations” we are making the assumption that the number of machine operations needed to perform, say, a multiplication is independent of the size of the numbers to be multiplied, which is false if the numbers are sufficiently large. Similar remarks hold for the estimates of space. Like the design and description of a process, the analysis of a process can be carried out at various levels of abstraction.
[fn:1] 那些命题掩饰了大量的过度简化. 例如, 如果我们将进程的步骤用 "机器操作" 统计, 我们假设需要进行的机器操作, 如, 一个乘法是独立于需要乘的数的大小的, 而这在数足够大时是不成立的. 相似的提示也作用于空间的估计. 就像一个进程的设计和描述, 对进程的分析可以在不同程度的抽象之上进行.
