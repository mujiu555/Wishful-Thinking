#+title: Chapter 1 2
#+author: 暮玖(github@mujiu555)

* 1.2 Procedures and the Processes They Generate 函数和它们产生的进程

We have now considered the elements of programming: We have used primitive arithmetic operations, we have combined these operations, and we have abstracted these composite operations by defining them as compound procedures. But that is not enough to enable us to say that we know how to program. Our situation is analogous to that of someone who has learned the rules for how the pieces move in chess but knows nothing of typical openings, tactics, or strategy. Like the novice chess player, we don’t yet know the common patterns of usage in the domain. We lack the knowledge of which moves are worth making (which procedures are worth defining). We lack the experience to predict the consequences of making a move (executing a procedure).

我们现在来考虑一下编程的要素: 我们已经使用过基本数值运算操作, 我们将那些操作组合, 并且我们已经通过将那些复合操作定义成为复合函数来将它们抽象. 但是它还不足以让我们说出, 我懂如何编程. 我们的状态类似于那些已经学习了国际象棋棋子移动规则而还不知道经典开场, 战术或策略的那些人. 就像国际象棋菜鸟, 我们还不知道这个领域(编程)的常用模式(common patterns). 我们缺乏值得下哪步棋(应该定义哪些函数)的知识. 我们缺乏预测下一步(执行函数)结果的经验.

The ability to visualize the consequences of the actions under consideration is crucial to becoming an expert programmer, just as it is in any synthetic, creative activity. In becoming an expert photographer, for example, one must learn how to look at a scene and know how dark each region will appear on a print for each possible choice of exposure and development conditions. Only then can one reason backward, planning framing, lighting, exposure, and development to obtain the desired effects. So it is with programming, where we are planning the course of action to be taken by a process and where we control the process by means of a program. To become experts, we must learn to visualize the processes generated by various types of procedures. Only after we have developed such a skill can we learn to reliably construct programs that exhibit the desired behavior.

要成为一个专家程序员在充分考虑后能可视化某些行为结果的能力是必不可少的, 就像在任何创造性活动中一样. 比如, 为了成为一个专业摄影师, 他必须学习如何取景, 知道打印后每个区域在不同曝光度和曝光时长的选择下将会多暗. 只有这样, 他才可以逆向推理, 简化帧, 光照, 曝光, 和时长, 去取得想要的结果. 这对我们计划一个进程的行为, 通过程序控制进程的编程也一样. 为了成为专家, 我们必须学习如何可视化不同种函数产生的进程. 只有我们培养了这种技能, 我们才能学习如何可靠地构建包含想要行为的程序.

A procedure is a pattern for the local evolution of a computational process. It specifies how each stage of the process is built upon the previous stage. We would like to be able to make statements about the overall, or global, behavior of a process whose local evolution has been specified by a procedure. This is very difficult to do in general, but we can at least try to describe some typical patterns of process evolution.

一个函数是一个计算进程如何在本地演变的模式. 它规定了一个进程是如何从上一个状态转变成为下一个状态的. 我们会可以作出对全体, 或全部, 由一个函数指定了本地演变方式的进程, 的一个命题. 这在总体上很难做到, 但是我们至少可以长逝描述一些进程变化的经典模式.

In this section we will examine some common “shapes” for processes generated by simple procedures. We will also investigate the rates at which these processes consume the important computational resources of time and space. The procedures we will consider are very simple. Their role is like that played by test patterns in photography: as oversimplified prototypical patterns, rather than practical examples in their own right.

在这一节中我们将了解一些常规的简单函数产生的进程的 "形状". 我们也会分析那些进程消耗的重要的时间和空间的计算资源的比率[fn:1]. 我们考虑的函数非常简单. 它们的作用类似摄像的测试图: 作为过度简化的摄影样板, 而不可实践的样例.

* Footnotes

[fn:1] 时间空间复杂度 O, OIer 很熟悉的(
