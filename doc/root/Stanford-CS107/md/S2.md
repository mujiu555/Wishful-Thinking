#

## Sec 2

### Binary Numbers

对于正数, 直接相加即可得到结果(在范围内)

对于含负数数, 需要通过一种方式表示它的正负性

+ 原码: 选取数值的最高位, 0为正1为负.

  直接用最高位为1的数表示, 与正数相加时可能会取得不正确的结果.
  对于一个负数, 不能采用通常二进制加法, 简单将最高位置1.
  
  ``` text
     00000000 000000111   (+7)
   + 10000000 000000111   (-7)
  ----------------------
     10000000 000001110   (-14)
  ```
  
  需要保证运算过后, 可以使得负数与对应正数相加值为0(最高位1溢出).

+ 反码 1's complement: 将数值原样取反.

  正数与绝对值相同的负数相加, 和为全1, 会造成＋0和－0问题
  
  ``` text
     00000000 000000111   (+7)
   + 11111111 111111000   (-7)
  ----------------------
     11111111 111111111   (0xffff)
  ```
  
+ 补码 2's complement: 将2中结果＋1, 则为所需结果, 对于实用, 将值加到负数中

  ``` text
     00000000 000000111   (+7)
   + 11111111 111111001   (-7)
  ----------------------
  (0)00000000 000000000   (0x0000)
  ```
  
  补码的数学含义: 模数加法构成阿贝尔群: 正整数的加法逆元
  
### Characters

字符本身即为数字

### Convert

小数值的赋值近似直接将对应值赋值到大数值的低位

大数值赋值到小数值空间, 直接抛弃高位

负数赋值会用符号位填充高位(逻辑赋值), 或填0

### Floats

+ 定点二进制小数: 采用几个位数表示 $$ 2^{-n} $$

  可以表示的整数和小数的位数一定,

  浮点数, 用以有限位数和精度逼近稠密数域上的精确小数

+ float 32: IEEE 754 2-based float number

  ``` text
  [sign] [<<--- mangnitude -->>] [<-fractions>]
  [1/0 ] [exp(unsigned integer)] [base(2^{-n})]
  ```

  实际上来说, val(10) = (-1)^{sign}* 1.base ^{exp-2^{bits(exp)-1}+1}

### Endian

最高位所在的字节称为大端，最低位所在的字节称为小端.

小端序: 高位在低字节
大端序: 高位在高字节

大端符合人类阅读习惯

指针指向会被字节序影响
