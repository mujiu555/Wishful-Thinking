#!ft=lisp; encode=utf-8
#!lang lilies

#;comment|
 ; Lilies Sample Code
|#

;; (lambda argument body)

;; Main function
(define f Type (Function ((Int u64) ((vec string))) => (Int u8)))
(define main f
  (lambda ((argc #:type (Int u64))
           (argv #:type ((vec string))))
    => ((Int u8))
    :body
    (sequence ent
      (displayln "Hello, World!")
      (:return 0)))
  "main: N, V(S) -> N")

;; void funcion
(define f Type (funcion () => ()))
(define fun:void f
  (lambda () => ()
    :body
    (sequence ent
      (:return))))

;; multiple returning
(define f Type (Function ((Int i32) (Int i32)) => (Int i32) (Int i32)))
(define div f
  (lambda ((dividend)
           (divider #:constraint (> _ 0)))
    => (#:name
        (quotient #:type (Int i32))
        (reminder #:type (Int i32)))
    :body
    (sequence ent
      (builtin:asm
        :input
        (dividend divider quotient reminder)
        :code
        (:mov Reg#rax (:ptr divider))
        (:mov Reg#rbx (:ptr dividend))
        (:xor Reg#rdx Reg#rdx)
        (:div Reg#rbx)
        ;;
        (:mov (:ptr quotient) Reg#rax)
        (:mov (:ptr reminder) Reg#rdx))
      (:return))))

;; optional parameter
(define f Type (Function (#&optional (Int i32)) => ()))
(define fun:opt f
  (lambda (#&optional (opt (Int i32)))
    => ()
    :body
    (:return)))

;; multiple parameter
(let ((f Type (Function rest => (Int i32))))
  (define f:mp f
    (lambda rest
      => (:name (i (Int i32)))
      :body
      (sequence ent
        (set! i (length rest))
        (:return)))))

;; a special kind of pattern match
;; () and anything inside it matches the parameter in lambda closure (lambda parameter body)
;; since list is represented in (cons car cdr)
;; (sth... . rest) will extract any more parameter to rest
;; or you may accept parameter list as a whole

;; with exception
(define f Type (Function () => ()))
(define f:ept f
  (lambda ()
    => ()
    :except (Exception Error)
    :body
    (:return)))

;; define constant
(define c:v1 (Int i32) 1)

;; define variable
(define v:v1 (Instance (Int i32)) (alloc:new (Int i32) #:init 1))

;; define array1d (length 5)
(define v:a1 (Instance (Int i32) 5) (alloc:new (Int i32) 5))

;; define array2d (length 5 3), all filled with 7
(define v:a2 (Instance (Int i32) 5 3) (alloc:new (Int i32) 5 3 #:init 7))

;; class, no parent
(define C:c1 Type
  (class ()
    #:super super
    #:self self
    #:type T
    (:fields
      #@[visible :public 'read :private 'write]
      (define v (Int u8) #:default 0)
      (define v2 (Int u32)))
    (:properties
      (define pv (Int u64) () GetPV SetPV))))

;; interface
(define I:i1 Constraint
  (interface ()
    #:self self
    #:type T
    :methods
    (add (T T) => T)))

;; generic funtion
(define g:add generic
  (generic #:type T (T T) => T ))
(define add generic
  (generic #:type T ((T) T) => T))

;; method
(define m Type (Method (C:c1 C:c1) => C:c1))
(define (method g:add C:c1) m
  (lambda ((a #:type C:c1)
           (b #:type C:c2))
    => (C:c1)
    :body
    (:return (alloc:new C:c1 #:init (v (add (field 'v a) (field 'v b)))))))

(define m Type (Method ((C:c1) C:c1) => C:c1))
(define (method add C:c1) m
  (lambda (self
           (obj #:type C:c1))
    => (C:c1)
    :body
    (:return (alloc:new C:c1 #:init (v (add (field 'v self) (field 'v obj)))))))

;; method call
(define o:o1 (Instance C:c1) (alloc:new C:c1 #:init (v 0)))
(define o:o2 (Instance C:c1) (alloc:new C:c1 #:init (v 0)))
({add o:o1} o:o2)
;; or
((method 'add o:o1) o:o2)

;; generic method call
(g:add o:o1 o:o2)
(add o:o1 o:o2)

;; inheritance
(define C:c2 Type
  (class (C:c1)
    #:self self
    #:type T
    (:fields
      (inherit v))))

(define (method add C:c2) m
  (inherit add))

;; structure
(define s:s1 Type
  (structure
    (define v (Int u32))))

;; union
(define u:u1 Type
  (structure
    (define u32 (Int u32))
    #@[offset 0]
    (define f32 (Float f32))

;; enumerator
(define e:e1 Type
  (enumerator
    (define e1)
    (define e2 (Int u32))))

;; tuple
(define (list t1 t2) (Tuple (Int i32) (Int i32))
  (div 10 2))
;; => t1 <- 5, t2 <- 0
;; pattern match, manually assignment

;; comments

(ignore) ; one line

;; one line

;;; splitor

#;comment| multiple line |#

#;comment|
 ; multiple line
|#

#;comment|
 ; #;comment|
 ;  ; Nested multiple line
 ; |#
 ;
 ; #+code|
 ;  + ;; sample code block
 ; |#
 ; #+code| lilies
 ;  + ;; sample code block with language specify
 ; |#
|#

#;comment| #param
 ; multiple line with param
|#

#;() ;temporary comment, anything inside () are commented

;; let
;; let:fwd
;; let:rec
;; let:rec:fwd

;; Module
(define m (module
  (import (inherit :std))
  (export main)
  :body
  (define main ? (global 'main))))
