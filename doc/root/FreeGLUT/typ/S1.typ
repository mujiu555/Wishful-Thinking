= 计图入门之FreeGLUT (1)

#set math.mat(delim: "[")
#set math.vec(delim: "[")

== Intro

本文为计图入门的第一篇, 主要以介绍 `FreeGLUT` 为主.

前文 #link("./S0.typ")["计图入门之FreeGLUT(0)"] .

#outline()

=== Background

说实话中文互联网里, 有关于 `FreeGLUT` 的资料不多,
基本是初学计图的Blog.

唯一可以找到的相关资料是 
#link("https://learnopengl-cn.github.io/")[主页 - LearnOpenGL CN],
而且它也是以 `glew` 为主要介绍目标.

同时, 不知道是否是搜索能力不足, 没办法找到 `FreeGLUT` 的完整API文档.
目前可见的 #link("https://freeglut.sourceforge.net/docs/api.php")[文档] 并不完整.

所以本文参考资料主要来源于
- #link("https://paroj.github.io/gltut/index.html")[Learning Modern 3D Graphics Programming]
- #link("https://openglbook.com/")[openglbook.com]

=== 吐槽

不过说真的, 用 `FreeGLUT` 画动画实在有点折磨的.

== Conventions

本文将遵循类似 "Learning Modern 3D Graphics Programming" 中的规则描述代码,
(但是很多地方不一样!)

- _defined term_: 术语表中有定义
- *FunctionNames*: 函数命名, Pascal风格
- nameOfVariables: 变量命名, 小驼峰风格
- GL_ENUMERATORS: 枚举常量
- /Paths/And/Files: 路径
- `<K>`: 按键 "K", `<S-K>` 才会得到字母 "K"

== 数学基础

=== Vector Math

从几何上来看, 向量可以表示一个特定空间中的位置或方向.
向量的位置表示了空间中的一个特定位置.

向量同样可以表示方向, 方向向量没有原点, 只是表示了空间中的位置.
所有位置向量只要方向和长度相同, 即可认为相同.

从代数角度来看, 向量是一系列的数字, 每一个表示一个维度的信息.
所以二维向量有两个数值, 三维向量有三个, 依此类推.

比如, 一个三维向量可以是 $angle.l X, Y, Z angle.r$, 而作为等式中的一部分时,
可以是
$ arrow(a) = vec(x, y, z) $

- 向量加法遵循平行四边形原则 (三角形原则), 从代数来看, 就是直接将对应维数相加.
- 向量的反向和减法, 直接取负向量即可反向向量, 减法可以通过加上一个负向量实现.
- 向量/标量乘法, 标量乘以对应维数.

向量运算遵循交换律, 结合律, 分配律.

向量的长度表示了向量的值大小, 终点到起点的距离, 在欧几里得坐标系内, 向量的范数为:
$ |arrow(a)| = sqrt(sum_(i=1)^n a_i^2) $

单位向量由自身除以范数得到, $ hat(arrow(a)) = 1/ (|arrow(a)|) $

=== 栅格化器流水线

所有计算机屏幕上被展示出来的东西都是通过二维的像素矩阵表示的.
当放大仔细看屏幕的时候, 可以看出来, 模糊的由三种不同颜色小灯泡展示的小方块.
这种小方块就是像素, "#text([*Pic*])ture #text([*El*])ement".
这种二维像素矩阵就组成了图像.

图形学的作用在于, 确定哪些颜色需要被放到哪些像素上.
当所有的图像都被映射到2D平面, 如何处理3D的对象? 将3D对象处理成为2D图像的过程,
被称作渲染.

有多种方式渲染3D图像, 一种可以实时应用图形硬件, 如, 显卡, 被称作栅格化,
使用栅格化方式渲染的系统被称作栅格化器.

栅格化器中, 所有的对象都是空壳, 有些方法可以允许你打开这些空壳, 
但是它只是用一些其他的空壳代替实际内部的样式.

所有的壳都用三角形组成. 所有的面都是三角形.
有些技术可以为对象产生更多的三角形, 这样它可以更精细.
但是它们总是三角形.

有些栅格化器会使用平行四边形, 所有的点, 都在同一平面.
因为硬件光栅化器总是使用三角形, 这样可以保证所有点都在统一平面.

一个由相邻三角形描述了外表面的对象, 被称作几何体, 模型, 或3D网格模型.
这些术语可以互相替换.

栅化的过程由多个阶段. 这些阶段被放在一个流水线里. 
三角形被投入顶部, 而图像在底部被产出.
这就是为什么栅格化对于硬件加速如此有用: 每个三角形被按顺序操作.
当其他的三角形, 正在进行其他阶段时, 可以新加入三角形到最顶部的步骤.

三角形和模型提交的光栅化器的顺序可以影响输出.
无论如何提交三角形表示的网格对象, 光栅化器都会以一种特殊步骤处理三角形.
直到上一个三角形完成绘制了再绘制下一个.

OpenGL时一个用于处理硬件光栅化器的API. 所以, 它是一个符合的光栅化器3D渲染器.
一个光栅化器接受一组用户输入的三角形, 对它们执行一些操作,
然后基于这些三角形, 写下像素点.
这是简化的OpenGL工作原理, 但是对于我们的目的非常有用.

=== 三角形和顶点

一个三角形由三个顶点.
顶点是一系列任意数据. 为了简化操作, 我们认为这个数据一定包含三维空间中的点.
它也许还包含其他的数据, 但是至少会有这个点.
任何三个不共线的点可以形成一个三角形.
所以三角形的最小信息包含了三个三维的点.

一个三维空间中的点由三个数字, 或, 坐标组成. 一个X轴坐标, 一个Y轴, 一个Z轴.
一般写于括号中 $angle.l X, Y, Z angle.r$.

== 光栅化

光栅化器流水线, 尤其是对于现代硬件, 非常复杂.
所以在详细了解OpenGL的渲染之前, 对流水线有个简单了解是非常重要的.
这些细节再没有高层了解之前, 会让人不知所措.

=== 剪辑空间变换

光栅化的第一步是将每个三角形的顶点变换到一个特定空间中的特定区域.
在这段空间中的东西都会被西安然在图像上, 而其他不位于区域内的都不会.
这个区域表明了用户想要去渲染的部分.

在OpenGL的说法中, 这个空间被称作剪辑空间,
在这个空间中的三角形顶点的位置, 被叫做剪辑坐标.

剪辑坐标系和常规的位置不同. 一个三维空间的位置有着三个坐标.
一个剪辑空间中的位置由四个坐标. 前三个是通常的X, Y, Z坐标.
第四个,W, 定义了剪辑坐标的范围.

剪辑空间对于一个三角形的每一个顶点都可以不同.
它是 X, Y, Z 方向上 [-W, W] 范围内的 3D 空间区域.
因此, 有着不同的w坐标的顶点, 与其他的顶点有着不同的剪辑空间方块.

对于剪辑空间, X指向右边, Y指向上边, Z指向前方, 远离视角的方向.

将顶点坐标变换到剪辑空间的过程非常随机.
OpenGL为这一步提供了很多灵活的操作空间.

因为剪辑空间是世界的可见变化版, 任何在这个空间之外的三角形都会被抛弃.
任何部分处于这个区域的三角形都要经历一个步骤叫做 "剪切".
这将整个大三角形编程多个更小的三角形,
这样这些更小的三角形才可以整个处于剪辑空间中.
这就是剪辑空间名称的由来.

== 正规化坐标系

剪辑空间很有趣, 但是不方便.
对于每个顶点, 这个空间的边界都是不同的, 这让三角形的可视化更加困难.
于是, 剪辑空间会被变换到一个更加合理的坐标空间: 正规化设备坐标.


