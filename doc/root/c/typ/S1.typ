= The C Programming Language
<the-c-programming-language>

#show raw: set text(font: (
  (name: "DejaVu Sans Mono", covers: "latin-in-cjk"),
  "SimHei"
))

#outline()

== Intro

C语言, 历史悠长, 自从它于80年代伴随 Unix 出现,
便成为了全世界开发者的心头好. 至今为止都依然被广泛使用.
上到各种琳琅满目的应用程序, 下到操作系统内核, 都可以由C编写,
都依赖C的代码.

举个例子: 世界上的绝大多数服务器, 都是由 `Linux` 承载着的, 而 `Linux`
的内核, 几乎只有 `C` 所编写的代码. 当然, 在大家的手机上,
任何一部安卓手机, 它的内核, 其实也是Linux, 可以说,
C 驱动着世界上绝大多数设备的运行.
(之所以不用Windows举例, 一是Windows是一个闭源产品,
二是Windows内核主要由微软自己魔改的C++代码编写)

C是一门高级语言, 但是何为高级语言?

== 高级语言

高级语言是相对于低级语言而言的. 一般而言, 我们所说的低级语言,
是各个不同设备上面的汇编语言, 这些语言非常强大, 可以操作 CPU,
也非常基础, 一旦没有它们, 任何后续的工作都无法进行.

但是它们的问题也非常严重. 那就是它们与平台极度绑定, 一段代码,
只能在特定平台上工作. 即便逻辑相似, 或者完全一致,
但是你还是不得不按照不同平台的规定, 为它们依次适配.
这仅仅只是开发过程, 就已经可以体会到通过低级语言开发程序的麻烦了.
而到了软件升级这一步骤, 这样的一套流程就更加恐怖, 复杂度直线上升.

而高级语言, 是一种对于低级语言共同特征的抽象,
帮助程序员写出可以在不同平台间无痛或相对轻松移植的代码.

当通过C编程语言进行工作的时候, 我们可以抽象出加减乘除等操作,
分别对应操作不同位数数据的汇编指令; 可以抽象出各种变量,
直接对应内存中的一段空间.

比如: 对于C而言, 无论哪个平台的加法都可以通过 `a + b` 来完成, 但是对于
`IBM` 兼容机型的 `x86_64` 架构 `intel` 语法宏汇编 (好长的定语) 而言,
则可能是 `ADD AH, BH`, `ADD AX, BX`, `ADD EAX, EBX`, 乃至于
`ADD RAX, RBX` 这里甚至只是考虑到只有两个通用寄存器参与运算的情况,
如果还有内存, 还要复杂的多. (其实如果用 `AT&T` 语法还能更复杂些, 毕竟
`AT&T` 还要考虑指令名的问题).

这就为程序的移植提供了极大的方便, 不再需要手动为不同的平台进行适配.

=== 中级语言

C语言虽然名义上是一个高级语言, 但是很多人并不这么认为,
因为C语言并不提供一种通用的内存管理方案.
所有的内存都需要由程序员自己来手动管理. 这为系统编程提供了便利,
但也造成了不少内存泄漏等问题. 依旧需要考虑与低级语言汇编相似的边界问题.

因此, 便有人将C语言称作中级语言, 过渡语言. 不过,
这不过是称呼上的差别而已.

=== 编译 & 解释

CPU 实际上只能够理解和运行二进制的机器码.
因此, 直接以人类可读形式写出来的代码, 计算机没有办法直接执行.
这就需要对代码进行 `编译`, 或者 `解释`.

#grid(
  columns: 7,
  rect[源代码],
  [$stretch(-->)^("编译")$],
  rect[汇编文件],
  [$stretch(-->)^("汇编")$],
  rect[目标二进制],
  [$stretch(-->)^("链接")$],
  rect[目标可执行]
)


1. 编译, 是将代码编译到汇编语言 (或其他语言),
  再通过汇编器生成对应二进制代码, 最后链接, 产生原生可执行程序
  (该可执行程序会最终包含操作系统需要的结构) 的一种过程.

#grid(
  columns: 7,
  rect[源代码],
  [$stretch(-->)$],
  rect[解释器],
  [$stretch(-->)$],
  rect[输出]
)

2. 解释, 则是不经过编译过程, 通过虚拟机, 或者解释器,
  随读入源文件执行代码的过程.

实际上, 对于现代语言, 编译型语言和解释型语言的区别并没有特别大.
比如, `Java` 语言就既需要编译到`JVM bytecode`,
也需要用 `JVM` 解释字节码运行.

而我们, 会因为一门语言更倾向于如何运行, 来说这个语言是编译型语言,
或解释型语言.
比如, C语言, 就是一门会要求编译, 再运行的语言, 因此,
我们认为, C语言, 是一门编译型语言.
再如, 大家或许熟悉的 Python语言,
便是通过解释器执行的, 因此才认为 python语言 是一门编译型语言.

== 环境

不知道大家是否喜欢玩 PC 上的游戏, 有时候玩游戏会提示缺少 `DirectX`
运行时环境, 编程也和玩游戏一样, 是需要环境的. 一般而言,
我们将这种专门用于开发程序的环境, 称作开发环境.
而将所有开发所需要的工具和开发环境本身, 一起打包, 并预先配置的软件系统,
就称作集成式开发环境(IDE).

在 Windows 平台上, 最常用的C语言 IDE 是 Microsoft (C) Visual Studio,
不过这个 IDE 以及它配套的编程环境, 都是为了 C++ 和 C\# 而量身设计的,
并不太适用于 C 语言, 而它强制要求的工程管理, 以及提供的过多功能,
也容易导致初学者眼花缭乱, 忽视C语言学习的核心.

而 MacOS 平台上, 苹果公司提供了 Xcode IDE, 不过除了不得不写 Swift,
也几乎没有人使用它.

Linux 平台, 最常用的 "IDE" 是 (Neo)Vim 和 Emacs, 不过,
并不适合所有人使用.

鉴于平台相对不易统一, 而以上三个平台, 均提供了相对简单的方式以
`LLVM-Clang` 编译器作为 C语言 的编程环境, 在此处,
我们将采用手动配置环境的方式, 来作为学习C语言的第一步. 这也是大多数教程,
机构, 学校, 并不会教授, 而对于后续编程学习至关重要的一个部分.

另两个个人认为相对重要的部分是工具的使用和工具与知识的区别, 分别可以在
"计算机教育中缺失的一课 (The Missing Semester of Your Computer Science
Education)" 和 "理论计算机导论 (Introduction to Theoretical Computer
Science)" 中找到.

=== 环境变量

环境变量是一种可以被程序读取, 并根据其值进行配置的一些 "键-值" 对.
简单的理解, 就是字典的索引, 当我试图索引一些信息的时候, 可以先去目录找到
"键", 然后根据 "键" 取得 "值".

而这些组合, 可以控制程序的行动. 目前需要了解,
并且对于今后都非常重要的一些环境变量分别是:

- `PATH`: Path 环境变量, 故名思义, 便是一些路径, 那么,
  究竟是什么东西的路径呢? 实际上, Path 是系统执行指令时的搜索路径的集合.
- 例如:
  当我们在控制台(命令行) 输入一些指令, 并试图执行它们的时候,
  操作系统就会通过 Path 环境变量搜索, 如果可以找到,
  就执行对应找到的指令, 如果没有, 则会报错.
- 当然,
  不只是我们自己执行指令的时候需要用到Path, 很多其他的程序也会通过 PATH
  来找到它需要的程序. 比如动态链接器 (`ld-linux-x86_64.so`)
- 好吧其实目前只用知道 PATH 一个就够了 (

=== Windows

对于 Windows 而言, 环境变量的修改非常便捷安全:

打开 文件资源管理器 (Explorer), 右键点选 "此电脑", 并在弹出菜单中选择
"属性" - "高级系统设置" - "高级" - "环境变量"
即可看见环境变量的配置窗口.

如果需要编辑任何之一, 只需要双击点选项目, 就可以看见对应修改界面了.

=== Linux, MacOS & \*nix

对于类Unix及Unix系统而言, 环境变量的修改往往和用户配置文件相关联. 不过,
实际上, 要在这类系统上安装 C 的编程环境, 完全不需要对环境变量做过多修改,
而可以简单通过几行命令完成.

以下是一些参考:

- MacOS:

```sh
xcode-select --install
```

- Linux (Debian & Ubuntu \*):

```sh
sudo apt install base-devel
```

- Linux (Arch \*):

```sh
sudo pacman -Syy gcc make
```

- Linux (RHEL & Fedora \*):

```sh
sudo dnf group install "Development Tools"
```

- FreeBSD:

```sh
pkg install gcc
```

== Hello, World

于是便到了我们的第一个程序: Hello, World!

这是一个来自于 C程序设计语言 (the C Programming Language) 中的例子,
同时, 它也陪伴了一代又一代新生的程序员.
带着我们对自己创造的新世界的欢呼.

```c
#include <stdio.h>

int main(void) {
  printf("Hello, World!");
  return 0;
}
```

大家可以用任何笔记本将这段代码写下, 将它保存 (不要放桌面) 为 `hello.c`.

然后, 我们就可以开始进行编译了:
+ 在文件所处的文件夹, 打开一个终端:
  Windows 直接右键选择"终端"; MacOS, 咱弃疗了
+ 输入 `dir` 确认文件是否存在
+ 最后, 输入 ```sh clang hello.c -o hello```

然后我们就会获得一个名为hello的文件 (`hello` 是文件名, `.exe` 叫拓展名).
这就是我们的目标可执行文件了!

大家可以在终端中输入 ```sh ./hello``` 来执行它.

=== Explanation

这段程序, 首先是一串以 '\#' 号开头的文本, 这句话表示,
我们引入了一个名叫stdio的库的定义.

'\#' 号, 实际上代表了 "预处理指令" 的开始, 这里的预处理指令就是
"include". Include指令常常被用来包含一个文件, 比如说这里, 就包含了 stdio.h
这个文件.

Stdio, 是 "Standard Input / Output" 的简称,
它定义了常用的输入和输出函数, 它也将会成为后续C语言程序设计中最常用的库.

那么include指令是怎么样确定它需要包含哪些文件的呢?
实际上这取决于他需要包含的文件通过什么包裹.
比如在这里, 我们就使用尖括号 ('\<' 和 '\>') 包裹了 stdio.h,
它表示编译器会从系统路径中查找,
如果找到这个文件, 就将这个文件完整展开在指令处.
而如果我们通过双引号 ('“') 包裹了 stdio.h,
编译器就会先尝试从当前目录查找文件了.

大家可以尝试, 在 `hello.c` 同目录, 创建一个 `stdio.h` 文件,
再重新编译一下这个程序, 看看是否会有区别.
如果将尖括号改成双引号呢?

=== Library

C语言的内核很小, 只包括了一些非常基础的功能, 而其他的部分则都通过库来提供.
同时又因为它相对比较简陋, 所以当我们使用它的库的时候需要一个描述文件,
这个文件就可以告诉编译器, 这个库提供了哪些功能.

比如我们下面会说到的 `printf` "函数", 就是由stdio.h文件告知编译器的.

那么什么是函数呢... 先卖个关子, 后面会对函数有详细的解释.

下面就是我们程序的主体了.

=== main

```c
int main(void) {
  // ...
}
```

这部分, 就是我们的程序开始执行的部分. 我们将它称作 "主函数定义".

它基本可以被认为是固定格式 (固定格式一共有四种, 托管环境三种, 非托管环境一种, 但是目前只需要会这一种即可).

```c
printf("Hello, World");
```

则是我们程序唯一的主体 --- 我们的程序实际上只干了这一件事 ---
输出 "Hello, World".

这里的 ```c printf``` 和它之后的圆括号的组合, 我们将其称作函数调用.
```c Printf(...)``` 的作用是, 将文本按照一定格式打印到屏幕上, "Print (with) format",
就是这个意思啦.
而这里的 ```c "Hello, World"``` 就是函数调用的参数, 它告诉 `printf` 函数,
要将什么东西给输出到屏幕.

不过这里只是简单介绍它的作用哦, 实际上 `printf` 函数的作用远不止这样简单的!
我们后续会有章节单独介绍它的功能.

```c
return 0;
```

这一句, 用于终止这个函数: "main".
当编译器看见这一句话, 就知道要结束这个函数的执行了... "返回".

这其实也涉及到了一些后面的知识, 所以目前记住主函数的结束, 必须写上这样一句 ```c return 0;```就可以了.

=== Expression: Sentence.

大家如果仔细观察了, 就会发现, main函数内部的两个东西, 结尾都是分号.

其实, 分号 (';'), 表示一个语句的结尾.

语句大致可以被分为五种:
+ 表达式语句
+ 函数调用
+ 流程控制语句
+ 复合表达式
+ 空语句

将会在后面详细讲解各个语句, 不过, 一定要记住, 每个语句的结尾都需要一个分号;

== Types

C 语言是一门静态类型语言. 那么, 这一句话就涉及到两个新知识点了!
- 什么是类型,
- 什么是静态类型?

作为一门计算机语言, C语言操作的实际上都是一些数值.
对于不同的数值, 我们会人为规定它是什么 "类型".

比如, 我们就将大小在 $-2147483648_((-2^31))~2147483647_((2^31-1))$
之间的整数视为 "整型数 (Integer)". 而同时, 我们也需要表示一些文本, 所以就有了所谓的 "字符(Character)" 类型和 "字符串([Character] String)" 类型.

不过为什么需要将不同类型区别开来呢?
很明显, 字符串是没有办法当作整数来处理的对吧!
#text([
  (除非你把它们当作范畴论范围上面的幺半群来看...
  当然这样也只能统一操作而没有办法让字符串和数字相加哦\~)
], size: 8pt)

那么静态类型是什么呢?

就像数学并不完全是数字的操作, 大部分时候也和未知数相关一样, 
计算机程序也有自己的 "未知数" 需要操作.
当我们需要计算一些东西的时候, 很多时候都需要一个叫做 "变量" 
的东西存储中间结果.
这个 "变量" 既然需要存储数据, 那么它就也需要一个类型.
毕竟, 不同类型的数据, 就上上面刚刚说明的, 有着不同的属性, 完全没有办法用同样的方式存储.

而 C语言 更进一步, 为了避免变量在多次赋值以后, 类型会不清,
干脆让我们在定义变量的时候就固定它可以承载的数据类型了.
#text([
  (实际原因当然不是这样啦, 实际上 C语言 必须有类型的信息,
  才能为变量分配空间, 而不同的类型一般而言需要的空间不同, 自然不可以混用,
  后续将在 "内存模型" 部分详细解说喵\~ >w<)
], size: 8pt)
这就是我们说的 "静态类型" 系统.

=== Literal

字面量, 就像我们在解数学题目的时候, 会写下一些系数, 一些常量,
字面量就是直接出现在程序当中的常量.

不过和常量有一些区别的是, 字面量是真正没有办法被改变的.
而计算机程序中的常量, 则仅仅只是表示一个变量不会被改变而已...
通过一些特殊的手段, 我们也是可以让一个常量打开心扉, 接受新的数值的.

=== Basic Data Types

对于简单的编程任务, C语言定义了一些基本数据类型.
它们涵盖了数字, 文本和逻辑(好吧其实并没有).

我们最常用, 并且也将最先介绍的就是整数家族了:
- `short`: 短整型, 相对于整型, 需要的内存更少, 只有16位空间
  但是相应的,可以表示的数值也越少.
- `int`: 整型, C语言中默认的数据类型, 一般为32位空间,
  也就是可以有31位二进制可以用于表示数据,
  上述的 $-2147483648 ~ 2147483647$ 便是它可以表示数据的范围
- `long`: 长整型, 相对于 `int`, 可能更长, 一般在处理大数据的时候才会用到
- `long long`: 真$dot$长整型, 确定的64位数据.

每当我们在代码里面写下一个整数, 它就会自然具有上述类型之一的信息.
比如:

```c
short s = 0;
int i = 65536;
long l = 2147483647;
long long = 2147483648ll;
```

这里, $0$, $65536$, $2147483647$就都是 "int" 类型的 "字面量",
而 $2147483648$ 就是一个 "long long" 类型的字面量了.

不过这些数字前面的类型和等于号都有些什么作用呢... 大家马上也会明白!
不过我们先来了解一下整数的变体们:
- `signed`: 有符号前缀, 表示该类型是一个有符号的数据, 
  一般而言, 整型都是有符号的
- `unsigned`: 有了上一条的提示, 当我们不需要表示数据的负数部分时,
  当然就可以用无符号类型了, 当我们用无符号来修饰一个变量的时候,
  它的表示范围就会从一半正一半负, 变成完全的正数哦, 相当于给 $NN$
  加上了一个$*$的上标, 变成了$NN^*$, 不仅如此, 它正数部分的表示范围也会翻倍
- 不过虽然被称作前缀, 它们其实也是可以 "单干" 的, 当只有前缀出现时,
  实际上 C语言 (标准) 会自动给他补上一个 int 的.

这里可以再来几个例子:

```c
signed int i = 2147483647;
unsigned int u = 2147482647u;
```

在整数之外, 我们自然还有小数.
在 C语言 中, 我们将小数称之为 "二进制浮点数" 简称 "浮点数".

C语言中的常用浮点数一共有三种, 分别是:
- `float`: 默认浮点数, 一共占用32位字长, 不过相对于整数,
  浮点数并没有精确的表示范围
- `double`: 双精度浮点数, 相对于 `float`, 它的表示精度更高
- `long double`: 双精度的升级版

不过为什么浮点数要叫做浮点数呢?
当然是因为它的小数点不是固定的啦.

不过, 也许还有人会疑惑, 什么叫做固定的小数点?
一般而言, 小数的位数不是无限的吗?
这当然还是因为计算机表示的局限性.

比如, 当我们需要表示金额的时候, 一般都可以写作 "XX元Y角Z分" 对不对, 
那么当我们想要统一在 "元" 表示的时候, 就可以写作 "XX.YZ元" 了.
那么这里, 我们相当于是将所有单位统一到 "元",
而给 "角" 和 "分" 固定在了小数点后两位.
这就是所谓的 "定点数". 或者说, "100倍放缩的定点数".

那么, 有了 "定点数" 的前置理解,
"浮点数" 或者 "动点数" (这是我瞎起的) 就好理解了.
因为定点数太过于固定, 只能适用于某些特殊场景.
所以就可以想到,
如果我们用一些方式, 记录住小数点的位置, 不就可以来表示任意形式的小数了吗.
于是, 浮点数就诞生了.
不过, 上面我们表示的 "定点数", 是以 10 为基底的十进制定点数, 而在计算机里,
我们使用二进制数来表示数据, 因此, 我们实际上使用的浮点数也是二进制表示的.
这就可以解释什么叫做 "二进制浮点数" 了.

另一部分, 在数值之外, 就是字符类型和字符串了.

我们在数学的学习中, 计算出的结果, 直接写在 "解" 字后面就可以,
这实际是一种得出结果的 "输出" 过程.
那么, 同为进行数学计算的计算机, 要如何组织它的输出呢?
当然就是靠字符串咯:

```c
printf("This Is A String");
```

依旧是熟悉的 `printf`, 不同的是它需要操作的字符串.

字符串, 顾名思义, 是一串连续的字符序列, 一般我们用双引号括住的一串连续文本来表示一个字符串字面量.

那么字符该怎么样表示呢?

很简单, 除了双引号, 我们还有单引号呀.
理想情况下, 所有的单引号包括的单个字符都是一个字符.
不过, 因为有些字符完全没有办法用键盘打出来, 所以我们也提供了另外一些方式:
- `'c'`: 单引号包括字符
- `'\ooo'`: 按8进制表示的字符
- `'\xhhh'`: 按16进制表示的字符

当然咯, 有些字符远超过了字符可以表示的长度(8位), 所以我们还有另一种字符类型:
"长字符" 类型.
- `L'c'`: 单引号包括的长字符
- `L'\ooo'`: 单引号包括的8进制表示长字符
- `L'\xhhhh'`: 单引号包括的16进制长字符

大家其实也可以看出来, 
长字符字面量实际上就是给普通的字符字面量添加了一个"L"前缀罢了.
那么实际上, 我们也可以用同样的方式, 把一个普通的字符串字面量变成长字符串:

```c
wprintf(L"Hello World");
```

注: 实际上中文字符都会超过字符类型可以表示的范围,
但是为什么普通字符串可以表示含有中文的文本呢?
比如, ```c printf("你好, 世界");```.
因为字符串实际上不一定是一个字符变量表示一个字符, 现在看来可能会有些绕口,
但是当我们讲到字符串实际的表示方式的时候, 就会很好理解了.

所以也不是特别需要用长字符串来表示文本了.

对了, 不知道大家有没有注意到, 当我们描述整数类型的时候, 并没有说到8位整数,
对应着其他语言中很常见的 ```java byte``` 类型?
这是因为, c语言用 ```c char```类型代替了8位整数, 所幸,
c语言中并不是很常用到8位的数值, 因此这样的代替也并不是很大的问题.
当我们真的需要它的时候, 也可以临时用 ```c char``` 类型充当一下.

=== Logical Values

当然, 计算机也不总是只处理数值.
作为一堆二三极管, 逻辑门, 晶体管拼接而成的产物,
有有着天生的二进制表示,
二进制逻辑也是计算机程序处理的内容之一.

先从简单的入手, 逻辑一共有两种状态,
是, 或者否, 在 C语言 中, 我们用了一种很简单的方式来表示:
- 数值为0: 否 (`false`),
- 否则: 是 (`true`).

很简单对不对.

=== Void Type

以上的类型, 都还很具体, 不过当我们需要表示 "这里没有东西" 呢?
该怎么办?

这时候我们就需要用到 `void` 类型了.
不过这里不解释太多, 我们将会在应用中见证它的使用.

== Mathematics Operations

有了数字, 并不能让我们进行计算, 我们还需要定义对于这些数字的运算才可以.

所以首先, 对于所有的数值, 不管是整型数家族的, 还是浮点数家族的,
都适用于我们熟悉的四则运算, `+`, `-`, `*`, '/'.

#table(
  columns: 4,
  stroke: none,
  table.hline(),
  table.header([Operations], [Description], [Form], [Comment]),
  table.hline(stroke: 0.5pt),
  [`+`], [两数相加, 并返回新的相加后的值], [```c A + B```], [],
  [`-`], [从前数中减去后数, 并返回新的相减后的值], [```c A - B```], [],
  [`*`], [两数相乘, 并返回新的乘积], [```c A * B```], [],
  [`/`], [前数除以后数, 并返回除商],[```c A / B```], [],
  table.hline(),
)

当然了, 由于取余数的操作太有用了,
实际上 C语言 也为整数和浮点数的取余操作定义了两个方式,
并将这种运算称作 "取模":

#table(
  columns: 4,
  stroke: none,
  table.hline(),
  table.header([Operations], [Description], [Form], [Comment]),
  table.hline(stroke: 0.5pt),
  [`%`], [取模], [```c A % B```], [],
  [`fmod`], [浮点数取模], [```c fmod(A, B)```], [该方法为函数调用, 仅对`double`类型浮点数生效],
  [`fmodl`], [浮点数取模], [```c fmodl(A, B)```], [该方法为函数调用, 对`float`类型浮点数生效],
  [`fmodf`], [浮点数取模], [```c fmodf(A, B)```], [该方法为函数调用, 对`long double`类型浮点数生效],
  table.hline(),
)

=== Logical Operations

=== Bitwise Logical

=== Overflow

=== Binary Calculation

=== 2's Completion

== Syntax

=== Statements

=== Expression

=== Code Block

=== Empty Lines & Space

=== Comment

== Variables & Variable space

== Type Convert

== Input And Output

=== ```c printf```

=== ```c scanf```

== Array

== C Style String

== Conditional Statement

== Loop

== Iterator

== Function

== Recursion

== Function Tail Call Optimization

== Stack

== Stack Variables, Local Variables

== Global Variables

== Variable Scope

== Variable Allocation

== Heap Space

== Memory Management

=== Virtual Memory (OS)

== Function Call

== Function Stack

== Function In Assembly

== User Defined Types

== `Struct`

=== Simulate `class` Using Structure

=== Virtual Function Table

== `Enum`

== `Union`

== Bit Field

== Structure space, Memory Alignment & Offset

== Pointers

=== Pointer offset, index & linked list

=== Void Pointers

=== Pointer Convert

== Pointer in Assembly

== Preprocessor

=== Header files

=== Macro, C Style Macro, Template, Process Macro in Rust, Extended Macro for Common Lisp & Hygiene Macro System

=== Compiler Comments

=== ```c #program```

== Meta-programming

== Compiler

=== Compile Process

=== Compiler Driver

=== Assembler

=== Assemble

=== Assembly Code

=== Linker

=== Link

== Dynamic Linked Library

== Static Linked Library

== Executable File

== Build Systems

== C Project Management

== Multiple File Compile

== Variable Decorator

== \_Generic
